% Preamble
\documentclass{article}
\setlength\parindent{0pt}

% Packages
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage[linktocpage]{hyperref}

\hypersetup{
    colorlinks   = true,
    urlcolor     = blue,
    linkcolor    = blue,
    citecolor   = red
}

\title{Screen View Protocol}
\author{Josh Brown}

\newcommand{\projectName}{Screen View}

% Document
\begin{document}
    \maketitle
    \newpage


    \section{Abstract}
    \projectName{} is an end to end encrypted remote screen viewing and controlling software. This document describes
    the protocols necessary to make it function.
    \newpage


    \tableofcontents
    \newpage


    \section{Definitions}
    The following definitions are used globally throughout the document:

    \begin{itemize}
        \item Host - The user that wants to share their screen to the Client
        \item Client - The user that wants to view and control the Host's screen
        \item Server - The intermediary server used for routing and proxying data between
    \end{itemize}


    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in \href{https://datatracker.ietf.org/doc/html/rfc2119}{RFC 2119}.

    \newpage
    \section{Remote Visual Display (RVD) Protocol}

    The RVD protocol is used to communicate mouse input, keyboard input, frame data, and clipboard data between the Host and the Client.\\

    All messages can occur over either TCP or UDP but it is strongly RECOMMENDED that the noted transport protocol is used.\\

    With the exception of the \emph{Handshake} messages. All RVD messages' first byte contain a number to indicate the message type.

    \subsection{Definitions}

    \begin{itemize}
        \item Display - A rectangular visual region that is shared by a Host to a Client. May or may not be \emph{Controllable}.
        \item Controllable - A \emph{Display} that accepts keyboard and mouse input.
    \end{itemize}

    \subsection{Handshake}

    \subsubsection{ProtocolVersion - TCP}
    Handshaking begins by the Host sending the client a \emph{ProtocolVersion} message. This lets the Client know the verison supported by the Host.\\

    The \emph{ProtocolVersion} message consists of 12 bytes interpreted as a string of ASCII characters in the format "RVD xxx.yyy" where xxx and yyy are the major and minor version numbers, padded with zeros.

    \begin{center}
        Host \textrightarrow Client\\
        \begin{tabular}{|c|}
            \hline
            version (11 bytes) -
            "\texttt{RVD 001.000}" \\
            \hline
        \end{tabular}
    \end{center}

    The client replies back either \texttt{0} to indicate the version is not acceptable and that the handshake has failed or \texttt{1} if the version is acceptable to the client and the handshake as succeeded. If 0 is sent, all communication MUST cease and and error SHOULD be displayed to user.

    \begin{center}
        Client \textrightarrow Host\\
        \begin{tabular}{|c|}
            \hline
            ok (1 byte) -
            \texttt{00000000} or \texttt{00000001} \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{Initialization}

    Once the handshake has succeeded the Host responds with a \emph{DisplayChange} message.

    \subsection{Control messages}
    Control messages are messages that instruct client about changes regarding the Host.

    \subsubsection{DisplayChange - TCP}
    A \emph{DisplayChange} message informs the client about the available \emph{Display}s. RVD supports up to 255 displays.

    \begin{center}
        Host \textrightarrow Client\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 1                                  \\
            \hline
            clipboard-readable (1 byte) - 0 or 1               \\
            \hline
            number-of-displays (1 byte) - 1-255                \\
            \hline
            displays-information (variable bytes)              \\
            \hline
            DisplayInformation \emph{number-of-displays} times \\
            \hline
        \end{tabular}
    \end{center}

    Each \emph{Display} has an associated \emph{DisplayInformation}. \emph{displays-information} contains \emph{number-of-displays} \emph{DisplayInformation}'s. A \emph{DisplayInformation} is defined below:

    \begin{center}
        \begin{tabular}{|c|}
            \hline
            display-id (1 byte)                                                          \\
            \hline
            width (2 bytes) - number of pixels of the width of this display              \\
            \hline
            height (2 bytes) - number of pixels of the width of this display             \\
            \hline
            cell-width (2 bytes) - number of pixels of the width of a cell in the grid   \\
            \hline
            cell-height (2 bytes) - number of pixels of the height of a cell in the grid \\
            \hline
            access (1 byte) - defined below                                              \\
            \hline
            name-length (1 byte) -  length of the name                                     \\
            \hline
            name (\emph{name-length} bytes) - display name (UTF-8)                       \\
            \hline
        \end{tabular}
    \end{center}

    \textbf{Restrictions:}

    \begin{itemize}
        \item \emph{cell-width} MUST be less than \emph{width}. \emph{cell-height} must be less than \emph{height}.\\ % // TODO define more restrictions %
        \item The \emph{access} byte defines what type of access is available for the display. The bits of the \emph{access} byte are described below in Big Endian.
    \end{itemize}


    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Bit} & \textbf{Description}                        \\
            \hline
            0            & Flush                                       \\
            \hline
            1            & \emph{Controllable}                         \\
            \hline
            2            & \multirow{6}{10em}{Reserved for future use} \\
            3            &                                             \\
            4            &                                             \\
            5            &                                             \\
            6            &                                             \\
            7            &                                             \\
            \hline
        \end{tabular}
    \end{center}

    If the \emph{Controllable} bit is 1 and the \emph{clipboard-readable} byte is set to 1, then the clipboard is writable. The \emph{Controllable} bit SHOULD be consistent throughout all displays.\\

    The \emph{Flush} bit indicates whether this display has changed, specifically if this \emph{display-id} refers to a different \emph{Display} than the same \emph{display-id} did in the previous \emph{DisplayChange} message. In initialization, this MUST always be 1 (as there is no previous \emph{DisplayChange}). If the display hasn't changed (0) then the frame data may be maintained. If \emph{Flush} is 0, \emph{width}, \emph{height} MUST remain the same as the previous \emph{DisplayChange} specified for the \emph{display-id}.

    \subsubsection{DisplayChangeReceived - TCP}

    The \emph{DisplayChangeReceived} message is sent in reply after receiving a \emph{DisplayChange} message. It indicates to the Host they may start sending \emph{FrameData} referencing the new \emph{DisplayInformation} in the most recent \emph{DisplayChange}.

    \begin{center}
        Client \textrightarrow Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 2 \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{MouseLocation - TCP/UDP}

    The \emph{MouseLocation} message send information about where the mouse is currently on the screen.
    The Host sends this information periodically throughout the session.
    The Host SHOULD send a \emph{MouseLocation} update when mouse input is received from the Host's system or in reply when it receives a \emph{MouseInput}.

    \begin{center}
        Host \textrightarrow Client\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 3                                \\
            \hline
            display-id (1 byte) - 0-255                      \\
            \hline
            x-location (2 bytes) - x coordinate of the mouse \\
            \hline
            y-location (2 bytes) - y coordinate of the mouse \\
            \hline
        \end{tabular}
    \end{center}

    \subsection{Input}

    Input messages (including \emph{MouseLocation}) may be sent over TCP or UDP. TCP is preferred in most situations. However, in situations where speed is prioritized over the guarantees TCP provides (such as gaming), UDP can be used.

    \subsubsection{MouseInput - TCP/UDP}

    \begin{center}
        Client \textrightarrow Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 4                                \\
            \hline
            display-id (1 byte) - 0-255                      \\
            \hline
            x-position (2 bytes) - x coordinate of the mouse \\
            \hline
            y-position (2 bytes) - y coordinate of the mouse \\
            \hline
            button-mask (1 byte) - described below           \\
            \hline
        \end{tabular}
    \end{center}

    %  https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#pointerevent %
    Indicates either pointer movement or a pointer button press or release. The pointer is now at (x-position, y-position), and the current state of buttons 1 to 8 are represented by bits 0 to 7 of button-mask respectively, 0 meaning up, 1 meaning down (pressed).\\

    On a conventional mouse, buttons 1, 2 and 3 correspond to the left, middle and right buttons on the mouse. On a wheel mouse, each step of the wheel is represented by a press and release of a certain button. Button 4 means up, button 5 means down, button 6 means left and button 7 means right.

    \subsubsection{KeyInput - TCP/UDP}

    The \emph{KeyInput} event sends key presses or releases.

    \begin{center}
        Client \textrightarrow Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 5                                                                  \\
            \hline
            down-flag (1 byte) - 0 or 1 to indicate whether the key is now pressed or released \\
            \hline
            key (4 bytes) - "keysym"                                                           \\
            \hline
        \end{tabular}
    \end{center}

    Details can be found at the \href{https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#keyevent}{RFB Spec}

    \subsection{Clipboard} % // TODO this needs to be worked on

    \subsubsection{ClipboardTypeRequest - TCP}

    Used to request clipboard types the Host supports.

    \begin{center}
        Client \textrightarrow Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 6 \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{ClipboardTypeResponse - TCP}

    Response to the \emph{ClipboardTypeRequest}

    \begin{center}
        Host \textrightarrow Client\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 7                          \\
            \hline
            number-of-clipboard-types (1 byte) - 0-255 \\
            \hline
            data (variable bytes) - described below    \\
            \hline
        \end{tabular}
    \end{center}

    \emph{number-of-clipboard-types} is always 0 if \emph{clipboard-readable} is 0.\\

    \emph{data} contains \emph{number-of-clipboard-types} \emph{ClipboardType}s. \emph{ClipboardType} is defined below.

    \begin{center}
        \begin{tabular}{|c|}
            \hline
            type-length (1 byte) - 1-255                             \\
            \hline
            type-name(\emph{type-length} bytes) - type name in ASCII \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{CopyRequest - TCP}

    This is a request for a keyboard contents. It can be made by either the Client or the Host.

    \begin{center}
        Client $\leftrightarrow$ Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 8                                        \\
            \hline
            type-length (1 byte) - 0-255                             \\
            \hline
            type-name(\emph{type-length} bytes) - type name in ASCII \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{CopyResponse - TCP}

    \emph{CopyResponse} message is a response to a \emph{CopyRequest}.

    \begin{center}
        Client $\leftrightarrow$ Host\\
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 9                                                                       \\
            \hline
            accepted (1 byte) - 0 or 1                                                              \\
            \hline
            \textbf{Below only if \emph{accepted} is 1}                                             \\
            \hline
            type-length (1 byte) - 0-255                                                            \\
            \hline
            type-name(\emph{type-length} bytes) - type name in ASCII                                \\
            \hline
            content-length (4 bytes) - the length of the content (maximum $2^{24}$ bytes or ~16MB ) \\
            \hline
            data (content-length bytes)                                                             \\
            \hline
        \end{tabular}
    \end{center}

    \emph{accepted} indicates whether the \emph{CopyRequest} was accepted. If 0, the rest of the message MUST not exist.
    If \emph{clipboard-readable} is 0, \emph{accepted} is always 0. A Client or Host may send this message without a request.
    If a \emph{CopyResponse} is unsolicited, then \emph{accepted} MUST be 1.\\

    \emph{data} is zlib compressed.

    \subsubsection{A note on Pasting}

    There is a no paste message. To paste data an unsolicited \emph{CopyResponse} may be sent and then the keyboard
    shortcut (ctrl+v or cmd+v) should be sent via the \emph{KeyboardMessage}

    \subsection{FrameData - UDP}
    The \emph{FrameData} message contains an update of a particular cell on a particular \emph{Display}.

    \begin{center}
        \begin{tabular}{|c|}
            \hline
            type (1 byte) - 10        \\
            \hline
            sequence-number (4 bytes) \\
            \hline
            cell-number (2 bytes)     \\
            \hline
            size (2 bytes)            \\
            \hline
            data (\emph{size} bytes)  \\
            \hline
        \end{tabular}
    \end{center}

    \emph{sequence-number} is an incrementing 32-bit counter for each \emph{FrameData} sent

    \emph{data} contains jpeg pixel data of the updated cell.

    \newpage
    \section{Weak Pre Shared Key, Key Authentication (WPSKKA) Protocol}

    \subsection{Introduction}

    This protocol is used to establish end to end encryption between the Host and the Client.

    In recent years end-to-end encryption has risen in popularity due to privacy and
    security concerns. However, many implementations of end-to-end encryption rely
    on a third party and/or are susceptible to man-in-the-middle attacks making them
    inadequate.\\

    Screen sharing applications are used for a multitude of different purposes. One
    common use case is an IT professional assisting somebody by remotely viewing and
    controlling their computer. Sensitive data could be visible on the user's
    screen. Therefore, end-to-end encryption is preferred.\\

    Additionally, IT professionals will often be communicating with the user via the
    telephone. This provides a bi-directional external channel to transfer
    information. However, people cannot and will not transfer large amounts or
    complicated data reliably. Simply communicating letters can be confusing. "B",
    "C", "D", "E", "G" all sound similar and can be confused. Therefore,
    communicating strictly numbers is ideal.\\

    This creates an issue. Short, purely numeric keys provide extremely low entropy.
    A 10 digit numerical code only provides about 33-bits of entropy. In fact, in
    order to get the ideal 128-bits of entropy a 39 digit key would need to be used.
    Users will not want to relay 39 digits over the phone.\\

    One common solution when using a weak password is using a KDF to perform
    key-stretching. However, a 10 digit numerical code has such a small key space
    that it is relatively easy to brute force. Government agencies, such as the NSA,
    or large companies, such as Microsoft or Google could easily brute-force even
    very slow KDFs such as argon2 or PBKDF2.\\

    \subsection{Existing Practice}

    Based on \href{https://static.teamviewer.com/resources/2017/07/TeamViewer-Security-Statement-en.pdf}{TeamViewer's security statement},
    TeamViewer is end-to-end encrypted. However, a rogue or malicious TeamViewer
    intermediary server could easily provide a different set of keys to each party
    and intercept all communication. The parties must trust this third party in
    order to achieve proper end-to-end encryption. TeamViewer also does not give the
    ability for users to check the fingerprint of the other party's public key.\\

    Other applications such as Zoom and Signal (and the Signal protocol itself) do
    give users the ability to verify some sort of fingerprint of the public key
    (\href{https://support.zoom.us/hc/en-us/articles/360048660871-End-to-end-E2EE-encryption-for-meetings#h_01ENGDKFFBKTF796CE03FTCH6J}{Zoom}
    and \href{https://signal.org/blog/safety-number-updates/}{Signal}). However, most
    users don't bother confirming the numbers. Again trusting the third party
    server.\\

    Solutions such as TLS do provide strong end-to-end encryption but rely on a
    third party Certificate Authority to sign public keys. This would not be
    possible in the aforementioned use case.\\

    \subsection{Goal}

    Elliptic Curve Diffie-Hellman provides a sufficiently secure means of arriving
    at a shared secret. The goal of this protocol is to authenticate Elliptic Curve public keys
    using a weak (3 bytes length, 24 bits of entropy) pre-shared key communicated
    via an external channel. The security of the external channel is out of scope
    for this protocol and will be assumed to be secure (see Security Considerations
    section).\\

    \subsection{Requirements}

    Communication between the parties should be minimized.\\

    The protocol should be secure in the case of a malicious Client and/or malicious
    Server. This means the protocol should not be susceptible to man-in-the-middle
    (MITM) attacks, and the Host should be able to self authenticate the Client
    without trusting the Server.\\

    \subsection{Other Protocol/Algorithms Definitions}

    The Secure Remote Password (SRP) protocol is defined in
    \href{(https://datatracker.ietf.org/doc/html/rfc2945}{RFC2945} and
    \href{https://datatracker.ietf.org/doc/html/rfc5054}{RFC5054}.\\

    Elliptic Curve Diffie-Hellman (ECDH) key exchange is described in
    \href{https://datatracker.ietf.org/doc/html/rfc60904}{RFC6090}.\\

    \subsection{Protocol}

    This protocol occurs after a connection is established between the Host and
    Client using the Server.\\

    The SRP group is the 2048-bit group from RFC5054:\\

    The hexadecimal value for the prime is:\\

    \begin{verbatim}
    AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294
    3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D
    CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB
    D5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF74
    7359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A
    436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D
    5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73
    03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6
    94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F
    9E4AFF73
    \end{verbatim}

    The generator is: 2.\\

    The Host generates the following:\\

    \begin{itemize}
        \item $PK_H/pk_H$- Host ephemeral elliptic curve Public/Private
        key using the \texttt{secp521r1} (P-521) curve
        \item $I$ - 128 bit cryptographical secure random number, used as the identity or
        username in SRP
        \item $S$ - SRP salt
        \item $P$ - 3 byte random cryptographical secure random number, used as the password
        in SRP
        \item $V$ - SRP verifier
        \item $b$ - SRP random private value
        \item $B$ - SRP public value
        \item $k$ - SRP K value
    \end{itemize}
    
    The Host sends S, I, and B to the Client.\\

    The Client generates:\\

    \begin{itemize}
        \item $PK_C/pk_C$- Client ephemeral elliptic curve Public/Private
        key using the \texttt{secp521r1} (P-521) curve
        \item $a$ - SRP random private value
        \item $A$ - SRP public value
        \item $u$ - SRP u value
        \item $k$ - SRP k value
        \item $x$ - SRP x value (hashed P value communicated externally to the client)
        \item $L$ - SRP session key
    \end{itemize}

    The Client sends the Host $A$, $PK_C$ and HMAC($PK_C$, $L$).\\

    The Host derives:\\
    
    \begin{itemize}
        \item $u$ - SRP U value
        \item $L$ - SRP session key
    \end{itemize}

    The Host authenticates $PK_C$ HMAC using $L$. If authentication is
    successful, the Host performs DHKE to derive, $T$ the shared secret.\\

    The Host sends the client $PK_H$ and HMAC($PK_H$, $L$).\\

    The Client authenticates $PK_H$ HMAC using $L$. If authentication is
    successful, the Client performs DHKE to derive, $T$ the shared secret.\\

    Both the Client and the Host encrypt all communication using AES-GCM with shared
    secret $T$.\\ % // TODO add step about KDF

    \subsection{Security Considerations}

    All authentication security is provided by the secrecy of $P$ during the initial
    exchange. If the external channel used to communicate $P$ is actively
    intercepted and an intermediary server is malicious, a MITM attack can be
    conducted by an adversary. However, this must be an active attack as disclosure
    of $P$ after the true $B$ value is known by the client renders this MITM attack
    impossible.\\

    A malicious server or client could attempt to brute force $P$. However, every
    attempt requires interaction with the Host. After a few failed attempts, the
    Host should generate a new $P$ value. If failed attempts continue, the Host
    should stop accepting connections all together and report an issue to the user.
    To prevent DOS (denial of service) attacks and/or a malicious client forcing the
    Host to regenerate $P$, the Server should add rate limiting and other DOS
    protection for Clients.\\

    In order to ensure perfect forward secrecy, new key pairs
    ($PK_{H/C}/pk_{H/C}$) should be generated for each session.

\end{document}
