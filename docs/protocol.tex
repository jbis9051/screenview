% Preamble
\documentclass{article}
\setlength\parindent{0pt}

% Packages
\usepackage{amsmath}
\usepackage{textcomp}
\usepackage{multirow}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[linktocpage]{hyperref}

\hypersetup{
    colorlinks   = true,
    urlcolor     = blue,
    linkcolor    = blue,
    citecolor   = red
}

\title{Screen View Protocol}
\author{Josh Brown}

\newcommand{\projectName}{Screen View}

% Document
\begin{document}
    \maketitle
    \newpage


    \section{Abstract}
    \projectName{} is an end to end encrypted remote screen viewing and controlling software. This document describes
    the protocols necessary to make it function.
    \newpage


    \tableofcontents
    \newpage


    \section{Definitions}
    The following definitions are used globally throughout the document:


    The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
    document are to be interpreted as described in \href{https://datatracker.ietf.org/doc/html/rfc2119}{RFC 2119}.

    \newpage


    \section{Introduction}

    This section describes the high level protocol for \projectName incorporating all the protocols defined below.
    Terms used in this section are defined in other sections.\\

    \subsection{Application Layers}

    The table belows is an abstract diagram of the different layers of \projectName. Each layer encapsulates all the
    below layers.

    \begin{center}
        \begin{tabular}{|l|}
            \hline
            Transport Layer                                         \\
            | Server Encryption Layer                               \\
            || Server Communication Layer                           \\
            ||| E2EE (Peer $\leftrightarrow$ Peer) Encryption Layer \\
            |||| Host $\leftrightarrow$ Client Communication Layer  \\
            \hline
        \end{tabular}
    \end{center}

    The Transport Layer is the OSI Transport Layer level protocol for networking (TCP or UDP). \\

    The Server Encryption layer provides security between the Server and a Peer (Client and Host). The Server
    Encryption Layer is discussed in \hyperlink{section.4}{4}.

    \subsection{Initialization}

    To begin, a Peer connects to the server over TCP and commences the Server Encryption Layer protocol for TCP
    defined in \hyperlink{section.4}{4}. Next the Server Communication Layer defined in section \hyperlink{section
    .5}{5} commences. All Server Communication Layer messages are encrypted and encapsulated in messages defined in
    the Server Encryption Layer. Once a session is established between two peers, the E2EE (Peer $\leftrightarrow$ Peer)
    Encryption Layer commences as defined in \hyperlink{section.6}{6}. All E2EE (Peer $\leftrightarrow$ Peer)
    Encryption messages are encapsulated in Server Communication Layer messages. Finally, the Host $\leftrightarrow$
    Client Communication Layer commences as defined in \hyperlink{section.6}{6}. All Host $\leftrightarrow$ Client
    Communication Layer messages are encrypted and encapsulated in E2EE (Peer $\leftrightarrow$ Peer) Encryption
    Layer messages.

    \subsection{Transport Messages Total Header Sizes}

    % TODO

    \newpage


    \section{Server Encryption Layer}

    The Server Encryption Layer provides security for communication between Peers and the Server. TCP and UDP have
    different security methods.

    \subsection{TCP}

    The TCP Server Encryption Layer is heavily based on a simplification of TLS 1.3 as defined in. % TODO defined in

    \subsubsection{PeerHello}

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 1              \\
            \hline
            16             & public-key    &                \\
            \hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{l}
            $(E_{peer}^{pub},E_{peer}^{priv}) := $DH-Generate()\vspace{0.5em}
            \\
            public-key := $E_{peer}^{pub}$
        \end{tabular}
    \end{center}

    \subsubsection{ServerHello}

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes}             & \textbf{Name}       & \textbf{Value} \\
            \hline
            1                          & type                & 2              \\
            \hline
            3                          & certificates-length &                \\
            \hline
            \emph{certificates-length} & certificate\_list   &                \\
            \hline
            16                         & public-key          &                \\
            \hline
            variable                   & certificate-verify  &                \\
            \hline
        \end{tabular}
    \end{center}

    certificate\_list is defined in \href{https://datatracker.ietf.org/doc/html/rfc8446#section-4.4.2}{RFC8446
    Section-4.4.2}.

    \begin{center}
        \begin{tabular}{l}
            $(E_{serv}^{pub},E_{serv}^{priv}) := \text{DH-Generate()}$\vspace{0.5em}
            \\
            public-key := $E_{serv}^{pub}$
        \end{tabular}
    \end{center}

    certificate-verify is defined in \href{https://datatracker.ietf.org/doc/html/rfc8446#section-4.4
.3}{RFC8445 Section-4.4.3} with the following modification. The content that is signed is:\\

    \begin{center}
        \begin{tabular}{l}
            content := ``SreenViewServerVerify'' $||$ 0 $||$ $E_{serv}^{pub}$
        \end{tabular}
    \end{center}

    The Client MUST validate all signatures in accordance with the TLS spec.

    \subsubsection{Transport Data Key Derivation}

    \begin{center}
        \begin{tabular}{l}
            $C_{peer} = DH(E_{serv}^{pub}, E_{peer}^{priv})$\vspace{0.5em}
            \\
            $C_{serv} = DH(E_{peer}^{pub}, E_{serv}^{priv})$\vspace{0.5em}
            \\
            $(T_{peer}^{send} = T_{serv}^{recv}, T_{peer}^{recv} = T_{serv}^{send}) := \text{KDF}(C_{peer} =
            C_{serv}, \epsilon)$\vspace{0.5em}\\
            $N_{peer}^{send} = N_{serv}^{recv} = N_{peer}^{recv} = N_{serv}^{send} := 0$
        \end{tabular}
    \end{center}

    \subsubsection{Subsequent Messages: Transport Data Messages}

    \begin{center}
        Peer $\leftrightarrow$ Server\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes}     & \textbf{Name} & \textbf{Value} \\
            \hline
            1                  & type          & 3              \\
            \hline
            2                  & data-length   &                \\
            \hline
            \emph{data-length} & data          &                \\
            \hline
        \end{tabular}
    \end{center}

    \begin{center}
        \begin{tabular}{l}
            data := AEAD($T_{m}^{send}$, $T_{m}^{send}$, $P$, $\epsilon$)
        \end{tabular}
    \end{center}

    Where $P$ is the payload to be transported

    \subsection{UDP}

    UDP encryption and authentication rely on the \emph{peer-id} and \emph{peer-key} values established in a session
    (described in \hyperlink{subsection.5.4}{5.4}). The Server should NOT
    process any messages that don't pass authentication.\\

    AEAD(key, counter, plain text, auth text) is defined as ChaCha20Poly1305 AEAD, as specified in RFC7539 [17],
    with its nonce being composed of 32 bits of zeros followed by the 64-bit little-endian value of counter.
    % TODO little endian?; Cite

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Bytes}       & \textbf{Name}  \\
            \hline
            16                   & \emph{peer-id} \\
            \hline
            8                    & counter        \\
            \hline
            UDP length - 8 bytes & data           \\
            \hline
        \end{tabular}
    \end{center}

    When a session is established, the \emph{counter} MUST be 0. The \emph{counter} MUST increment by 1 for every UDP
    message sent by the Peer.

    \emph{data} is AEAD(\emph{peer-key}, \emph{counter}, \emph{plaintext}, $\epsilon$).

    \newpage


    \section{Screen View Server Communication (SVSC) Protocol }

    The SVSC protocol is the Server Communication Layer protocol used for Peers to interact with the relay server,
    Server. Peers can lease an ID as well as begin a session with another Peer. Once a session is established, Peers can
    forward messages to another Peer. Unless otherwise noted, all messages MUST occur over TCP.\\

    With the exception of the \emph{Handshake} messages. All SVSC messages' first byte contain a number to indicate
    the message type.

    \subsection{Definitions}
    The following definitions are used globally throughout the document:

    \begin{itemize}
        \item Peer - denotes a client in classical server/client environment
        \item Server - The intermediary server used for routing and proxying data between
    \end{itemize}

    \subsection{Handshake}

    \subsubsection{ProtocolVersion}

    Handshaking begins by the Server sending the Peer a \emph{ProtocolVersion} message. This lets the server know
    the version supported by the Host.\\

    The \emph{ProtocolVersion} message consists of 12 bytes interpreted as a string of ASCII characters in the format
    "SVSC xxx.yyy" where xxx and yyy are the major and minor version numbers, padded with zeros.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value}            \\
            \hline
            11             & version       & ``\texttt{SVSC 001.000}'' \\
            \hline
        \end{tabular}
    \end{center}

    The Peer replies back either \texttt{0} to indicate the version is not acceptable and that the handshake has
    failed or \texttt{1} if the version is acceptable to the Peer and the handshake as succeeded. If 0 is sent, all
    communication MUST cease and the TCP connection MUST be terminated.

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & ok            & 0 or 1         \\
            \hline
        \end{tabular}
    \end{center}

    \subsection{Leasing}

    A lease is a temporary assignment of an ID to a Peer. The ID format and generation is discussed in
    \hyperlink{subsubsection.4.2.5}{4.2.5}. A maximum of 1 ID can be leased per TCP connection. ID generation MUST be
    rate limited to prevent ID exhaustion. Rate limiting rules are out of scope for this protocol, however some
    suggestions are listed in \hyperlink{subsubsection.4.2.6}{4.2.6}.

    \subsubsection{LeaseRequest}

    A \emph{LeaseRequest} message requests a lease of an ID.

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 1              \\
            \hline
            1              & has-cookie    & 0 or 1         \\
            \hline
            \multicolumn{3}{|c|}{\textbf{Below only if \emph{has-cookie} is 1} } \\
            \hline
            24             & cookie        &                \\
            \hline
        \end{tabular}
    \end{center}

    If a Peer would like to request an ID it had previously been issued after expiration, it may include the cookie
    value it received in the \emph{LeaseResponse}.

    \subsubsection{LeaseResponse}

    A \emph{LeaseResponse} message is a response to a \emph{LeaseRequest}.

    If \emph{has-cookie} is 1, a Server MAY consider the \emph{cookie} value in \emph{LeaseRequest} or completely
    ignore it.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 2              \\
            \hline
            1              & accepted      & 0 or 1         \\
            \hline
            \multicolumn{3}{|c|}{\textbf{Below only if \emph{accepted} is 1} } \\
            \hline
            4              & id            &                \\
            \hline
            24             & cookie        &                \\
            \hline
            8              & expiration    &                \\
            \hline
        \end{tabular}
    \end{center}

    \emph{expiration} is a 64 bit Unix timestamp representing the expiry of lease. Disconnection of a Peer (e.g,
    the TCP connection is dropped) does not end a lease.\\

    \emph{cookie} a 128 bit value. The generation of this value is discussed in \hyperlink{subsubsection.4.2.7}{4.2
    .7}.\\

    Consideration of the \emph{cookie} value MUST have no effect on the the value of \emph{accepted}. That is, if the
    request is for a specific ID (implied by the presence of a cookie value and a \emph{has-cookie} value equal to 1
    in the \emph{LeaseRequest}) and the ID requested is not available, the Server SHOULD respond with a different
    available ID and an \emph{accepted} value of 1 (assuming an ID is available).\\

    \emph{accepted} SHOULD only be 0 if no IDs are left or for rate limiting reasons.

    \subsubsection{LeaseExtensionRequest}

    A \emph{LeaseExtensionRequest} message is used to extend a lease. Before a lease has expired, the Peer can
    request a lease extension. The server can accept or deny this request.

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 3              \\
            \hline
            24             & cookie        &                \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{LeaseExtensionResponse}

    A \emph{LeaseExtensionResponse} message is a response to a \emph{LeaseExtensionRequest}.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name}  & \textbf{Value} \\
            \hline
            1              & type           & 4              \\
            \hline
            1              & extended       & 0 or 1         \\
            \hline
            \multicolumn{3}{|c|}{\textbf{Below only if \emph{extended} is 1} } \\
            \hline
            8              & new-expiration &                \\
            \hline
        \end{tabular}
    \end{center}

    \emph{new-expiration} is a 64 bit Unix timestamp representing the expiry of lease.

    \subsubsection{ID Generation}

    An ID is a 26 to 33 bit decimal number. This comes out to about up to 8 to 10 decimal digits, respectively. The
    Server may scale the keyspace depending on current usage. For optimal user experience while maintaining
    efficiency, the Server MUST only use keyspaces between 26 bits and 33 bits for ID generation. ID generation must
    also be uniformly random. All active IDs must be stored on the server. ID generation MAY occur using the below
    algorithm:\\

    Let $S$ represents a set of all active IDs, $B$ be a number of bits between 26 and 33, and $generate(x)$ be a
    functions that returns a $x$ uniformly random bits.

    \begin{algorithm}
        \caption{ID generation}
        \begin{algorithmic}
            \State $id$
            \Repeat
                \State $id\gets generate(B)$
            \Until{$id\notin S$}
            \State $S\gets S\cup \{id\}$
            \State \textbf{return} $id$
        \end{algorithmic}
    \end{algorithm}

    \subsubsection{Rate Limits}

    To prevent ID exhaustion, rate limits SHOULD be in place. TCP is used for \emph{LeaseRequests} so IP addresses
    can not be spoofed. However, using proxy services such as Tor, simple IP based rate limits are likely not
    entirely sufficient. Servers MAY want to block all known proxy IP addresses. Additionally, a Server MAY only want
    to allow one active ID per Peer.

    \subsubsection{Cookie Value}

    A \emph{cookie} value is a 128 bit value used for authentication in \emph{LeaseExtensionRequest} and
    \emph{LeaseRequest} messages. Specific generation of a \emph{cookie} is out of scope, however care must be taken
    to ensure it is not predictable or exploitable. This value MAY be simply a random 24 byte key, HMAC-SHA1($id$,
    $key$) $||$ $id$, or something else entirely.

    \subsection{Sessions}

    A session is a connection between two Peers. At least one Peer must have an ID. A Peer can have a maximum of one
    session at any time. Immediately after receiving a \emph{EstablishSessionResponse} message with a \emph{status}
    of 1 or a \emph{EstablishSessionNotification} message a Peer MUST begin the UDP Heartbeat procedure defined in %
    TODO
    and continue for the duration of the session. Failure to do so MAY result in dropped \emph{SessionData*} packets.

    \subsubsection{EstablishSessionRequest}

    An \emph{EstablishSessionRequest} message is a Peer request to establish a connection to a Peer.

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}                                 \\
            \hline
            1              & type          & 5              &                                                      \\
            \hline
            4              & lease-id      &                & The ID of the Peer to establish this connection with \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{EstablishSessionResponse}

    An \emph{EstablishSessionResponse} message is a response to \emph{EstablishSessionRequest}.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}                       \\
            \hline
            1              & type          & 6              &                                            \\
            \hline
            4              & lease-id      &                & the ID of the Peer attempted to connect to \\
            \hline
            1              & status        & 0-3            & described below                            \\
            \hline
            \multicolumn{4}{|c|}{\textbf{Below only if \emph{status} is 0} } \\
            \hline
            16             & session-id    &                & described below                            \\
            \hline
            16             & peer-id       &                & described below                            \\
            \hline
            16             & peer-key      &                & described below                            \\
            \hline
        \end{tabular}
    \end{center}

    \emph{status} can have the following values:

    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Value} & \textbf{Description}                 \\
            \hline
            0              & session establishment was successful \\
            \hline
            1              & ID not found                         \\
            \hline
            2              & Peer is offline                      \\
            \hline
            3              & Peer is busy                         \\
            \hline
            4              & You are busy                         \\
            \hline
            3              & Other error                          \\
            \hline
        \end{tabular}
    \end{center}

    A Peer may be considered offline if, for example, an unexpired ID has been assigned to them and then the TCP
    connection is dropped. Heartbeat messages and timeouts are discussed in % TODO
    .\\

    \emph{session-id} is a 128 bit random value used for session identification\\

    \emph{peer-id} is a 128 bit random value used to authentication a peer for a given session.\\

    \subsubsection{EstablishSessionNotification}

    A \emph{EstablishSessionNotification} notifies a Peer that a session has been established with them.

    \begin{center}
        Server \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}                                \\
            \hline
            1              & type          & 7              &                                                     \\
            \hline
            16             & session-id    &                & described in \hyperlink{subsubsection.4.3.2}{4.3.2} \\
            \hline
            16             & peer-id       &                & described in \hyperlink{subsubsection.4.3.2}{4.3.2} \\
            \hline
            16             & peer-key      &                & described in \hyperlink{subsubsection.4.3.2}{4.3.2} \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{SessionEnd}

    A \emph{SessionEnd} message is used to terminate a session. Once a Server receives a \emph{SessionEnd} message,
    % // TODO

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description} \\
            \hline
            1              & type          & 8              &                      \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{SessionEndNotification}

    A \emph{SessionEndNotification} notifies a Peer that a session has ended. If a Client sends a \emph{SessionEnd}
    message, the Server MUST send a \emph{SessionEndNotification} message to a Host.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description} \\
            \hline
            1              & type          & 9              &                      \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{SessionDataSend - TCP/UDP}

    A \emph{SessionDataSend} is a message from a Peer intended to be forwarded to the Peer on the other side of the
    session.

    \begin{center}
        Peer \textrightarrow\ Server\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}           \\
            \hline
            1              & type          & 10             &                                \\
            \hline
            3              & data-length   &                & length of the content in bytes \\
            \hline
            data-length    & data          &                & data to be forwarded           \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{SessionDataReceive - TCP/UDP}

    A \emph{SessionDataReceive} is a message being forwarded to a Peer from the Peer on the other side of the
    session. The Server SHOULD forward the message along the same transport as it was received.

    \begin{center}
        Server \textrightarrow\ Peer\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}           \\
            \hline
            1              & type          & 11             &                                \\
            \hline
            3              & data-length   &                & length of the content in bytes \\
            \hline
            data-length    & data          &                & data to be forwarded           \\
            \hline
        \end{tabular}
    \end{center}

    \newpage


    \section{Remote Visual Display (RVD) Protocol}

    The RVD protocol is used to communicate mouse input, keyboard input, frame data, and clipboard data between the
    Host and the Client.\\

    All messages can occur over either TCP or UDP but it is strongly RECOMMENDED that the noted transport protocol is
    used.\\

    With the exception of the \emph{Handshake} messages. All RVD messages' first byte contain a number to indicate
    the message type.

    \subsection{Definitions}

    \begin{itemize}
        \item Host - A peer with an ID that wants to share their screen to the Client
        \item Client - A peer that wants to view and maybe control the Host's screen
        \item Display - A rectangular visual region that is shared by a Host to a Client. May or may not be
        \item \emph{Controllable}.
        \item Controllable - A \emph{Display} that accepts keyboard and mouse input.
    \end{itemize}

    \subsection{Handshake}

    \subsubsection{ProtocolVersion - TCP}
    Handshaking begins by the Host sending the client a \emph{ProtocolVersion} message. This lets the Client know the
    verison supported by the Host.\\

    The \emph{ProtocolVersion} message consists of 11 bytes interpreted as a string of ASCII characters in the format
    "RVD xxx.yyy" where xxx and yyy are the major and minor version numbers, padded with zeros.

    \begin{center}
        Host \textrightarrow\ Client\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value}           \\
            \hline
            11             & version       & ``\texttt{RVD 001.000}'' \\
            \hline
        \end{tabular}
    \end{center}

    The client replies back either \texttt{0} to indicate the version is not acceptable and that the handshake has
    failed or \texttt{1} if the version is acceptable to the client and the handshake as succeeded. If 0 is sent, all
    communication MUST cease and an error SHOULD be displayed to user.

    \begin{center}
        Client \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & ok            & 0 or 1         \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{Initialization}

    Once the handshake has succeeded the Host responds with a \emph{DisplayChange} message.

    \subsection{Control messages}
    Control messages are messages that instruct client about changes regarding the Host.

    \subsubsection{DisplayChange - TCP}
    A \emph{DisplayChange} message informs the client about the available \emph{Display}s. RVD supports up to 255
    displays.

    \begin{center}
        Host \textrightarrow\ Client\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name}        & \textbf{Value}            \\
            \hline
            1              & type                 & 1                         \\
            \hline
            1              & clipboard-readable   & 0 or 1                    \\
            \hline
            1              & number-of-displays   & 1 - 255                   \\
            \hline
            variable       & displays-information & \emph{DisplayInformation} \\
            \hline
        \end{tabular}
    \end{center}

    Each \emph{Display} has an associated \emph{DisplayInformation}. \emph{displays-information} contains
    \emph{number-of-displays} \emph{DisplayInformation}'s. A \emph{DisplayInformation} is defined below:

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes}     & \textbf{Name} & \textbf{Description}                                 \\
            \hline
            1                  & display-id    &                                                      \\
            \hline
            2                  & width         & number of pixels of the width of this display        \\
            \hline
            2                  & height        & number of pixels of the width of this display        \\
            \hline
            2                  & cell-width    & number of pixels of the height of a cell in the grid \\
            \hline
            2                  & cell-height   & number of pixels of the height of a cell in the grid \\
            \hline
            1                  & access        & defined below                                        \\
            \hline
            1                  & name-length   & length of the \emph{display-name} in bytes           \\
            \hline
            \emph{name-length} & display-name  & the display name (UTF-8)                             \\
            \hline
        \end{tabular}
    \end{center}

    \textbf{Restrictions:}

    \begin{itemize}
        \item \emph{cell-width} MUST be less than \emph{width}. \emph{cell-height} must be less than \emph{height}.\\
        % // TODO define more restrictions %
        \item The \emph{access} byte defines what type of access is available for the display. The bits of the
        \item \emph{access} byte are described below in little endian.
    \end{itemize}


    \begin{center}
        \begin{tabular}{|c|c|}
            \hline
            \textbf{Bit} & \textbf{Name}                               \\
            \hline
            0            & Flush                                       \\
            \hline
            1            & \emph{Controllable}                         \\
            \hline
            2            & \multirow{6}{10em}{Reserved for future use} \\
            3            &                                             \\
            4            &                                             \\
            5            &                                             \\
            6            &                                             \\
            7            &                                             \\
            \hline
        \end{tabular}
    \end{center}

    If the \emph{Controllable} bit is 1 and the \emph{clipboard-readable} byte is set to 1, then the clipboard is
    writable. The \emph{Controllable} bit SHOULD be consistent throughout all displays.\\

    The \emph{Flush} bit indicates whether this display has changed, specifically if this \emph{display-id} refers to
    a different \emph{Display} than the same \emph{display-id} did in the previous \emph{DisplayChange} message. In
    initialization, this MUST always be 1 (as there is no previous \emph{DisplayChange}). If the display hasn't
    changed (0) then the frame data may be maintained. If \emph{Flush} is 0, \emph{width}, \emph{height} MUST remain
    the same as the previous \emph{DisplayChange} specified for the \emph{display-id}.

    \subsubsection{DisplayChangeReceived - TCP}

    The \emph{DisplayChangeReceived} message is sent in reply after receiving a \emph{DisplayChange} message. It
    indicates to the Host they may start sending \emph{FrameData} referencing the new \emph{DisplayInformation} in
    the most recent \emph{DisplayChange}.

    \begin{center}
        Client \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 2              \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{MouseLocation - TCP/UDP}

    The \emph{MouseLocation} message send information about where the mouse is currently on the screen.
    The Host sends this information periodically throughout the session.
    The Host SHOULD send a \emph{MouseLocation} update when mouse input is received from the Host's system or in
    reply when it receives a \emph{MouseInput}.

    \begin{center}
        Host \textrightarrow\ Client\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}      \\
            \hline
            3              & type          & 3              &                           \\
            \hline
            1              & display-id    & 0-255          &                           \\
            \hline
            2              & x-location    &                & x coordinate of the mouse \\
            \hline
            2              & y-location    &                & y coordinate of the mouse \\
            \hline
        \end{tabular}
    \end{center}

    \subsection{Input}

    Input messages (including \emph{MouseLocation}) may be sent over TCP or UDP. TCP is preferred in most situations.
    However, in situations where speed is prioritized over the guarantees TCP provides (such as gaming), UDP can be
    used.

    \subsubsection{MouseInput - TCP/UDP}

    \begin{center}
        Client \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}      \\
            \hline
            1              & type          & 4              &                           \\
            \hline
            1              & display-id    & 0-255          &                           \\
            \hline
            2              & x-position    &                & x coordinate of the mouse \\
            \hline
            2              & y-position    &                & y coordinate of the mouse \\
            \hline
            1              & button-mask   &                & described below           \\
            \hline
        \end{tabular}
    \end{center}

    %  https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#pointerevent %
    Indicates either pointer movement or a pointer button press or release. The pointer is now at (x-position,
    y-position), and the current state of buttons 1 to 8 are represented by bits 0 to 7 of button-mask respectively,
    0 meaning up, 1 meaning down (pressed).\\

    On a conventional mouse, buttons 1, 2 and 3 correspond to the left, middle and right buttons on the mouse. On a
    wheel mouse, each step of the wheel is represented by a press and release of a certain button. Button 4 means up,
    button 5 means down, button 6 means left and button 7 means right.

    \subsubsection{KeyInput - TCP/UDP}

    The \emph{KeyInput} event sends key presses or releases.

    \begin{center}
        Client \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} & \textbf{Description}                                 \\
            \hline
            1              & type          & 5              &                                                      \\
            \hline
            1              & down-flag     & 0 or 1         & indicates whether the key is now pressed or released \\
            \hline
            4              & key           &                & "keysym"                                             \\
            \hline
        \end{tabular}
    \end{center}

    Details can be found at the \href{https://github.com/rfbproto/rfbproto/blob/master/rfbproto.rst#keyevent}{RFB Spec}

    \subsection{Clipboard} % // TODO this needs to be worked on

    \subsubsection{ClipboardTypeRequest - TCP}

    Used to request clipboard types the Host supports.

    \begin{center}
        Client \textrightarrow\ Host\\
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name} & \textbf{Value} \\
            \hline
            1              & type          & 6              \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{ClipboardTypeResponse - TCP}

    Response to the \emph{ClipboardTypeRequest}

    \begin{center}
        Host \textrightarrow\ Client\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name}             & \textbf{Value} & \textbf{Description} \\
            \hline
            1              & type                      & 7              &                      \\
            \hline
            1              & number-of-clipboard-types & 0-255          &                      \\
            \hline
            variable       & data (variable bytes)     &                & described below      \\
            \hline
        \end{tabular}
    \end{center}

    \emph{number-of-clipboard-types} is always 0 if \emph{clipboard-readable} is 0.\\

    \emph{data} contains \emph{number-of-clipboard-types} \emph{ClipboardType}s. \emph{ClipboardType} is defined below.

    \begin{center}
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes}     & \textbf{Name} & \textbf{Value} & \textbf{Description} \\
            \hline
            1                  & type-length   & 1-255          &                      \\
            \hline
            \emph{type-length} & type-name     &                & type name in ASCII   \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{CopyRequest - TCP}

    This is a request for a keyboard contents. It can be made by either the Client or the Host.

    \begin{center}
        Client $\leftrightarrow$ Host\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes}     & \textbf{Name} & \textbf{Value} & \textbf{Description} \\
            \hline
            1                  & type          & 8              &                      \\
            \hline
            1                  & type-length   & 1-255          &                      \\
            \hline
            \emph{type-length} & type-name     &                & type name in ASCII   \\
            \hline
        \end{tabular}
    \end{center}

    \subsubsection{CopyResponse - TCP}

    \emph{CopyResponse} message is a response to a \emph{CopyRequest}.

    \begin{center}
        Client $\leftrightarrow$ Host\\
        \begin{tabular}{|c|c|c|c|}
            \hline
            \textbf{Bytes}        & \textbf{Name} & \textbf{Value} & \textbf{Description} \\
            \hline
            1                     & type          & 9              &                      \\
            \hline
            1                     & accepted      & 0 or 1         &                      \\
            \hline
            \multicolumn{4}{|c|}{\textbf{Below only if \emph{accepted} is 1} } \\
            \hline
            1                     & type-length   & 1-255          &                      \\
            \hline
            \emph{type-length}    & type-name     &                & type name in ASCII   \\
            \hline
            3 & content-length & & the length of the content  (maximum $2^{24}$
            bytes or ~16MB ) \\
            \hline
            \emph{content-length} & data          &                & zlib'ed raw data     \\
            \hline
        \end{tabular}
    \end{center}



    \emph{accepted} indicates whether the \emph{CopyRequest} was accepted. If 0, the rest of the message MUST not exist.
    If \emph{clipboard-readable} is 0, \emph{accepted} is always 0. A Client or Host may send this message without a
    request.
    If a \emph{CopyResponse} is unsolicited, then \emph{accepted} MUST be 1.\\

    \emph{data} is zlib compressed.

    \subsubsection{A note on Pasting}

    There is a no paste message. To paste data an unsolicited \emph{CopyResponse} may be sent and then the keyboard
    shortcut (ctrl+v or cmd+v) should be sent via the \emph{KeyboardMessage}

    \subsection{FrameData - UDP}
    The \emph{FrameData} message contains an update of a particular cell on a particular \emph{Display}.

    \begin{center}
        \begin{tabular}{|c|c|c|}
            \hline
            \textbf{Bytes} & \textbf{Name}   & \textbf{Value} \\
            \hline
            1              & type            & 10             \\
            \hline
            4              & sequence-number &                \\
            \hline
            1              & display-id      & 0-255          \\
            \hline
            2              & cell-number     &                \\
            \hline
            2              & size            &                \\
            \hline
            \emph{size}    & data            &                \\
            \hline
        \end{tabular}
    \end{center}

    \emph{sequence-number} is an incrementing 32-bit counter for each \emph{FrameData} sent

    \emph{data} contains jpeg pixel data of the updated cell.

    \newpage


    \section{Weak Pre Shared Key, Key Authentication (WPSKKA) Protocol}

    \subsection{Introduction}

    This protocol is used to establish end to end encryption between the Host and the Client.

    In recent years end-to-end encryption has risen in popularity due to privacy and
    security concerns. However, many implementations of end-to-end encryption rely
    on a third party and/or are susceptible to man-in-the-middle attacks making them
    inadequate.\\

    Screen sharing applications are used for a multitude of different purposes. One
    common use case is an IT professional assisting somebody by remotely viewing and
    controlling their computer. Sensitive data could be visible on the user's
    screen. Therefore, end-to-end encryption is preferred.\\

    Additionally, IT professionals will often be communicating with the user via the
    telephone. This provides a bi-directional external channel to transfer
    information. However, people cannot and will not transfer large amounts or
    complicated data reliably. Simply communicating letters can be confusing. "B",
    "C", "D", "E", "G" all sound similar and can be confused. Therefore,
    communicating strictly numbers is ideal.\\

    This creates an issue. Short, purely numeric keys provide extremely low entropy.
    A 10 digit numerical code only provides about 33-bits of entropy. In fact, in
    order to get the ideal 128-bits of entropy a 39 digit key would need to be used.
    Users will not want to relay 39 digits over the phone.\\

    One common solution when using a weak password is using a KDF to perform
    key-stretching. However, a 10 digit numerical code has such a small key space
    that it is relatively easy to brute force. Government agencies, such as the NSA,
    or large companies, such as Microsoft or Google could easily brute-force even
    very slow KDFs such as argon2 or PBKDF2.\\

    \subsection{Existing Practice}

    Based on \href{https://static.teamviewer.com/resources/2017/07/TeamViewer-Security-Statement-en.pdf}{TeamViewer's
    security statement},
    TeamViewer is end-to-end encrypted. However, a rogue or malicious TeamViewer
    intermediary server could easily provide a different set of keys to each party
    and intercept all communication. The parties must trust this third party in
    order to achieve proper end-to-end encryption. TeamViewer also does not give the
    ability for users to check the fingerprint of the other party's public key.\\

    Other applications such as Zoom and Signal (and the Signal protocol itself) do
    give users the ability to verify some sort of fingerprint of the public key
    (\href{https://support.zoom.us/hc/en-us/articles/360048660871-End-to-end-E2EE-encryption-for-meetings
#h_01ENGDKFFBKTF796CE03FTCH6J}{Zoom}
    and \href{https://signal.org/blog/safety-number-updates/}{Signal}). However, most
    users don't bother confirming the numbers. Again trusting the third party
    server.\\

    Solutions such as TLS do provide strong end-to-end encryption but rely on a
    third party Certificate Authority to sign public keys. This would not be
    possible in the aforementioned use case.\\

    \subsection{Goal}

    Elliptic Curve Diffie-Hellman provides a sufficiently secure means of arriving
    at a shared secret. The goal of this protocol is to authenticate Elliptic Curve public keys
    using a weak (3 bytes length, 24 bits of entropy) pre-shared key communicated
    via an external channel. The security of the external channel is out of scope
    for this protocol and will be assumed to be secure (see Security Considerations
    section).\\

    \subsection{Requirements}

    Communication between the parties should be minimized.\\

    The protocol should be secure in the case of a malicious Client and/or malicious
    Server. This means the protocol should not be susceptible to man-in-the-middle
    (MITM) attacks, and the Host should be able to self authenticate the Client
    without trusting the Server.\\

    \subsection{Other Protocol/Algorithms Definitions}

    The Secure Remote Password (SRP) protocol is defined in
    \href{(https://datatracker.ietf.org/doc/html/rfc2945}{RFC2945} and
    \href{https://datatracker.ietf.org/doc/html/rfc5054}{RFC5054}.\\

    Elliptic Curve Diffie-Hellman (ECDH) key exchange is described in
    \href{https://datatracker.ietf.org/doc/html/rfc60904}{RFC6090}.\\

    \subsection{Protocol}

    This protocol occurs after a connection is established between the Host and
    Client using the Server.\\

    The SRP group is the 2048-bit group from RFC5054:\\

    The hexadecimal value for the prime is:\\

    \begin{verbatim}
    AC6BDB41 324A9A9B F166DE5E 1389582F AF72B665 1987EE07 FC319294
    3DB56050 A37329CB B4A099ED 8193E075 7767A13D D52312AB 4B03310D
    CD7F48A9 DA04FD50 E8083969 EDB767B0 CF609517 9A163AB3 661A05FB
    D5FAAAE8 2918A996 2F0B93B8 55F97993 EC975EEA A80D740A DBF4FF74
    7359D041 D5C33EA7 1D281E44 6B14773B CA97B43A 23FB8016 76BD207A
    436C6481 F1D2B907 8717461A 5B9D32E6 88F87748 544523B5 24B0D57D
    5EA77A27 75D2ECFA 032CFBDB F52FB378 61602790 04E57AE6 AF874E73
    03CE5329 9CCC041C 7BC308D8 2A5698F3 A8D0C382 71AE35F8 E9DBFBB6
    94B5C803 D89F7AE4 35DE236D 525F5475 9B65E372 FCD68EF2 0FA7111F
    9E4AFF73
    \end{verbatim}

    The generator is: 2.\\

    The Host generates the following:\\

    \begin{itemize}
        \item $PK_H/pk_H$- Host ephemeral elliptic curve Public/Private
        key using the \texttt{secp521r1} (P-521) curve
        \item $I$ - 128 bit cryptographical secure random number, used as the identity or
        username in SRP
        \item $S$ - SRP salt
        \item $P$ - 3 byte random cryptographical secure random number, used as the password
        in SRP
        \item $V$ - SRP verifier
        \item $b$ - SRP random private value
        \item $B$ - SRP public value
        \item $k$ - SRP K value
    \end{itemize}

    The Host sends S, I, and B to the Client.\\

    The Client generates:\\

    \begin{itemize}
        \item $PK_C/pk_C$- Client ephemeral elliptic curve Public/Private
        key using the \texttt{secp521r1} (P-521) curve
        \item $a$ - SRP random private value
        \item $A$ - SRP public value
        \item $u$ - SRP u value
        \item $k$ - SRP k value
        \item $x$ - SRP x value (hashed P value communicated externally to the client)
        \item $L$ - SRP session key
    \end{itemize}

    The Client sends the Host $A$, $PK_C$ and HMAC($PK_C$, $L$).\\

    The Host derives:\\

    \begin{itemize}
        \item $u$ - SRP U value
        \item $L$ - SRP session key
    \end{itemize}

    The Host authenticates $PK_C$ HMAC using $L$. If authentication is
    successful, the Host performs DHKE to derive, $T$ the shared secret.\\

    The Host sends the client $PK_H$ and HMAC($PK_H$, $L$).\\

    The Client authenticates $PK_H$ HMAC using $L$. If authentication is
    successful, the Client performs DHKE to derive, $T$ the shared secret.\\

    Both the Client and the Host encrypt all communication using AES-GCM with shared
    secret $T$.\\ % // TODO add step about KDF

    \subsection{Security Considerations}

    All authentication security is provided by the secrecy of $P$ during the initial
    exchange. If the external channel used to communicate $P$ is actively
    intercepted and an intermediary server is malicious, a MITM attack can be
    conducted by an adversary. However, this must be an active attack as disclosure
    of $P$ after the true $B$ value is known by the client renders this MITM attack
    impossible.\\

    A malicious server or client could attempt to brute force $P$. However, every
    attempt requires interaction with the Host. After a few failed attempts, the
    Host should generate a new $P$ value. If failed attempts continue, the Host
    should stop accepting connections all together and report an issue to the user.
    To prevent DOS (denial of service) attacks and/or a malicious client forcing the
    Host to regenerate $P$, the Server should add rate limiting and other DOS
    protection for Clients.\\

    In order to ensure perfect forward secrecy, new key pairs
    ($PK_{H/C}/pk_{H/C}$) should be generated for each session.

\end{document}
